type Player = enum { None, X, O };

impl Player {
	const default = fn () -> Player => Player.None;

	const get_opposite = fn match &Player -> Player {
		.X => Player.O,
		.O => Player.X,
		_ => Player.None
	};

	const switch = fn (self : &mut Player) => self = self.get_opposite();

	const to_char = fn match &Player -> char {
		.X => 'X',
		.O => 'O',
		_ => ' '
	};
};

const get_pos = fn (x y : int) -> int => y * 3 + x;

const get_user_input = fn () -> int => {
	let x_txt = match std::console::input("Enter x position (min = 1, max = 3): ") {
		.Some : value => value,
		_ => "1"
	};
	
	let y_txt = match std::console::input("Enter y position (min = 1, max = 3): ") {
		.Some : value => value,
		_ => "1"
	};
	
	let mut x : int = x_txt as int;
	let mut y : int = y_txt as int;
	
	x -= 1;
	y -= 1;
	
	get_pos(x, y);
};

type Board = struct (list:<Player>);

impl Board {
	const default = fn () -> Board => Board(list:<Player>[Player.None for _ in 0..9]);

	const print_board = fn (self : &Board) => {
		print("|---|---|---|");
		
		// std.console.clear();
		for y in 0..3 => {
			let mut out : str = "| ";
			for x in 0..3 => {
				let point : Player = self.0[y * 3 + x];
				out &= point.to_char();
				out &= " | ";
			};
			print(out);
			print("|---|---|---|");
		};
	};

	const is_full = fn (self : &Board) -> bool => {
		let count = len([x for x in self.0 if x == Player.None]);
		count == 0;
	};

	const get_winner = fn (self : &Board) -> Player => {
		for y in 0..3 => {
			let y_adj = y * 3;
			if self.0[y_adj] != Player.None && self.0[y_adj] == self.0[y_adj + 1] && self.0[y_adj] == self.0[y_adj + 2] => {
				return self.0[y_adj];
			};
		};
		
		for x in 0..3 => if self.0[x] != Player.None && self.0[x] == self.0[x + 3] && self.0[x] == self.0[x + 6] => return self.0[x];
		
		if self.0[0] != Player.None && self.0[0] == self.0[4] && self.0[0] == self.0[8] => return self.0[0];
		
		if self.0[2] != Player.None && self.0[2] == self.0[4] && self.0[2] == self.0[6] => return self.0[2];
		
		Player.None;
	};

	const get_pos_value = fn (self : &Board, x y : int) -> Player => self.0[get_pos(x, y)];

	const get_user_input_checked = fn (self : &Board) -> int => {
		let mut index = -1;
		
		for index < 0 || index >= 9 || self.0[index] != Player.None => {
			self.print_board();
			
			// std.console.clear();
			if index != -1 => print("Try again.");
			index = get_user_input();
		};
		
		print(index);
		index;
	};

	const set_user_input = fn (self : &mut Board, player : Player) => self.0[self.get_user_input_checked()] = player;

	const get_best_position = fn (self : &mut Board, player : Player) -> int => {
		let maximising = player == Player.X;
		let mut best_pos = 0;
		let mut best_value = INT_MAX;
		if maximising => best_value = INT_MIN;
		
		for i in 0..9 => {
			if self.0[i] != Player.None => continue;
			
			self.0[i] = player;
			let value = minimax(self, player.get_opposite(), 0);
			self.0[i] = Player.None;
			
			if maximising => {
				if best_value < value => {
					best_value = value;
					best_pos = i;
				};
			} else => {
				if best_value > value => {
					best_value = value;
					best_pos = i;
				};
			};
		};
		
		best_pos;
	};
};

const minimax = fn (board : &mut Board, player : Player, depth : int) -> int => {
	match board.get_winner() {
		.X => return 100 - depth,
		.O => return -100 + depth,
		.None => {}
	};
	
	(board.is_full()) ? return 0 : null;
	
	let maximising = player == Player.X;
	let mut best_value = (maximising) ? INT_MIN : INT_MAX;
	
	for i in 0..9 => {
		(board.0[i] != Player.None) ? continue : null;
		
		board.0[i] = player;
		let value = minimax(board, player.get_opposite(), depth + 1);
		board.0[i] = Player.None;

		match maximising {
			true if best_value < value => best_value = value,
			false if best_value > value => best_value = value,
			_ => {}
		}
	};
	best_value;
};

const get_ais = fn () -> <bool, bool> => {
	let mut ais = tuple(false, false);
	
	let x_txt = match std::console::input("Enter \'y\' to make Player X (1) an AI: ") {
		.Some : value => value,
		_ => ""
	};
	
	let o_txt = match std::console::input("Enter \'y\' to make Player O (2) an AI: ") {
		.Some : value => value,
		_ => ""
	};
	
	if trim(x_txt) == "y" => ais.0 = true;
	if trim(o_txt) == "y" => ais.1 = true;
	
	ais;
};

const main = fn () => {
	for  => {
		let ais = get_ais();
		let both_ais = ais.0 && ais.1;
		let mut board : Board = Board.default();
		let mut player : Player = Player.X;
		
		for !board.is_full() && board.get_winner() == Player.None => {
			// std.console.clear();
			board.print_board();
			
			if ais.0 && Player.X == player || ais.1 && Player.O == player => {
				board.0[board.get_best_position(player)] = player;
				if both_ais => std::thread::wait(4);
				player.switch();
				continue;
			};
			
			board.set_user_input(player);
			player.switch();
		};
		
		// std.console.clear();
		board.print_board();
		
		match board.get_winner() {
			.X => print("Player X Won!"),
			.O => print("Player O Won!"),
			.None => print("Tied!")
		};
	};
};
