import (Channel, WaitGroup) from std::async;

/* Label scopes & loops pseudocode
const main = fn() => {
	// Example of a simple loop that is able to return a value
	// value's type should be able to be inferred
	let mut value = for i in 0..10 => {
		if i > 8 => break i;
	} else => {
		0;
	};

	// Example of a simple labelled block
	value = => @basic_block {
		if value > 8 => break @basic_block 100;

		60;
	};

	// This does the same thing as the previous example except it now creates a scope macro as well
	// The previous example was just a labelled scope that couldn't be re-used as a scope macro, this one can but still manages to still allow for scope breaking 
	value = => @basic_block[$val = 100, $other = 60] {
		if value > 8 => break @basic_block $val;

		$other;
	};

	// reusing the scope macro from before with different values
	value = => @basic_block[$val = 800, $other = 90];
	
	// This showcases how labelled loops can work allowing you to break/continue an outer loop from an inner one 
	value = for x in 0..100 => @outer{
		for y in 0..100 => {
			if y > 40 => continue @outer;

			if x == y => break @outer 50;
		}else {
			60;
		}
	} else => {
		70;	
	}
}
*/
type NumType = struct { num : int } @overload {

	const "+" = fn (self : NumType, value : int) -> int => {
		// TODO Add support for Self type
		return self.num + value;
	};

	const "/" = fn (self : NumType, value : int) -> int => {
		return self.num / value;
	};
};

let => @mult_scope [$ident = adder_int, $t = type : int] const $ident = fn (first : dyn, second : $t) -> $t => {
	print("multiplyer");
	return first * second;
};

let @float_mult_scope => @mult_scope [$ident = adder_float, $t = type : float];

=> @mult_scope [];
=> @float_mult_scope [];
=> @float_mult_scope [$ident = adder_flt];

const print_text = fn (values : list:<str>) => {
	print(values);
};

const main = fn () => {
	let name = "Ty";
	let age = "10";
	
	// TODO Add defer keyword
	let txt : str = fmt"Hello, my name is {name} and I'm {age} years old!";
	print(txt);
	
	print(adder_float(90, 10.6));
	
	print("piping");
	40 |: forty > adder_float(forty) |> $(80) |> fn (input : float) => print(input);
	
	print("overload");
	let mut num = NumType { num : 10 };
	let res = num + 10;
	print(res);
	let res = (num + 90) / 2;
	print(res);
	print("overload done");
	
	// The inputs get combined into a list
	print_text("1", "2", "6");
	
	let mut d = [[2, 0, 4], [1, 9, 3], [4, 7, 9], [9, 0, 1]];
	let lst = list:<int>[2, 0, 4];
	
	let mtchfn = fn match str -> int {
		"hello" => 0,
		_ => 10
	};
	
	print(mtchfn("he"));
	
	let mut match_res : int = match "hello" {
		"hello" => 0,
		_ => 10
	};
	
	print(match_res);
	
	let => @add_scope [$first = 9f, $second = 11f, $t = type : float] {
		// match_res will be captured at the call_site
		let sum : $t = $first + $second + match_res;
		print("add_scope: ");
		print(sum);
	};
	
	=> @add_scope [];
	match_res = 60;
	=> @add_scope [];
	
	=> @add_scope [$first = (5f / 99f)];
	
	// Now it doesn't create a new scope overriding the default implementation
	=> @add_scope [$first = 30, $second = 70, $t = type : int] {{}};
	print(sum + 10);
	
	let mut correct = -10;
	let mut other = -10;
	
	let hello = try ok("Yesssss") : hello => {
		print("Nooooo");
	};
	
	print(hello);
	
	(false) ? (8 == 9) ? correct : other : other = 0;
	
	// until allows you to end test the loop with the condition only breaking at the end of each iteration
	for i in 0..10 => print("hello") until true;
	
	// until also works with list comprehensions
	let lst = [10 for i in 10 until i > 4];
	print(lst);
	
	print(correct);
	print(other);
	
	// for i in 0..5 => print(i);
	let mut sum_ch : Channel:<int> = Channel:<int>.new();
	let mut fac_ch : Channel:<int> = Channel:<int>.new();
	
	let wg = spawn {
		=> {
			let mut s = 0;
			for i in 0..1000 => s += i;
			sum_ch.send(s);
		},
		=> {
			let mut f = 1;
			for i in 1..6 => f *= i;
			fac_ch.send(f);
		}
	};
	
	wg.wait();
	let sum = match sum_ch.get() {
		.Some : v => v,
		.None => 0
	};
	let fac = match fac_ch.get() {
		.Some : v => v,
		.None => 0
	};
	print("parallel sum=" & sum);
	print("parallel fac=" & fac);
	print("Ho");
};