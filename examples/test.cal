/* Future thread system pseudocode
// This language feature will be heavily inspired by goroutines from go as I think it's probably the best async programming syntax
// Firstly I need to remove the async keyword from the lexer and parser as I'm no longer going down the async/aswait route

// Importing wait groups and channels into the scope;
import (WaitGroup, Channel) from std::async;

// A non-mut reference to a channel means that you can only receive data not send it
// But a mut reference allows you to do both
const reader = fn (id : int, ch : &Channel:<int>, wg : &mut WaitGroup) => {
	// wg.add(1) should also be allowed
	wg.increment();
	// defer return wg.done() would also work in this context
	defer wg.done();

	for !ch.closed() => {
		if let .Some(val) <- ch.get() => fmt"Reader {id} received {val}" |> print;
	}

	fmt"Reader {id} closing" |> print;
}

const main = fn () => {
	// Use of in built generics syntax to avoid the syntax feeling disconnected from the language
	let mut ch : Channel:<int> = Channel:<int>.new();
	let mut wg : WaitGroup = WaitGroup.new();
	
	// The following code would not be run in sync
	// Also my language will allow scopes to just be used in this syntax, allowing you to not have to create a new function call
	spawn => print("1");
	spawn => print("2");
	spawn => print("3");
	
	for i in 0..100 => spawn reader(i, &ch, &mut wg);

	for i in 0..10000 => {
		// To send data into a channel its just a function call :
		ch.send(90);
		// Pipes are also valid
		// 90 |> ch.send	
	}
	
	ch.close();
	wg.wait();
}
*/

type NumType = struct {
	num : int,
} @overload {
	// TODO Add support for Self type
	const "+" = fn(self: NumType, value : int) -> int => {
		return self.num + value;
	}

	const "/" = fn(self: NumType, value : int) -> int => {
		return self.num / value;
	}
}

let => @mult_scope [$ident = adder_int, $t = type : int] const $ident = fn (first : dyn, second : $t) -> $t => {
	print("multiplyer");
	return first * second;
};

let @float_mult_scope => @mult_scope [$ident = adder_float, $t = type : float];

=> @mult_scope [];
=> @float_mult_scope [];
=> @float_mult_scope [$ident = adder_flt];

const print_text = fn (values : list:<str>) => {
	print(values);
};

const main = fn () => {
	let name = "Ty";
	let age = "10";
	// TODO Add defer keyword
	
	// In these string function blocks "{{}}" can be used to mean "{}"
	let txt : str = fmt"Hello, my name is {name} and I'm {age} years old!";
	print(txt);
	
	print(adder_float(90, 10.6));

	print("piping");
	40 |: forty > adder_float(forty) |> $(80) |> fn(input : float) => print(input);

	print("overload");
	let mut num = NumType{num : 10};
	let res = num + 10;
	print(res);
	let res = (num + 90) / 2;
	print(res);
	print("overload done");
	
	// The inputs get combined into a list
	print_text("1", "2", "6");
	
	let mut d = comp, 0 => list[list[2, 0, 4], list[1, 9, 3], list[4, 7, 9], list[9, 0, 1]];
	let lst = list:<int>[2, 0, 4];
	
	let mtchfn = fn match str -> int {
		"hello" => 0,
		_ => 10
	};
	
	print(mtchfn("he"));

	let mut match_res : int = match "hello" {
		"hello" => 0,
		_ => 10,
	};
	print(match_res);
	
	let => @add_scope [$first = 9.0, $second = 11.0, $t = type : float] {
		// match_res will be captured at the call_site
		let sum : $t = $first + $second + match_res;
		print("add_scope: ");
		print(sum);
	};
	
	=> @add_scope [];
	match_res = 60;
	=> @add_scope [];
	
	=> @add_scope [$first = (5.0 / 99.0)];
	
	// Now it doesn't create a new scope overriding the default implementation
	=> @add_scope [$first = 30, $second = 70, $t = type : int] {{}};
	print(sum + 10);
	
	let mut correct = -10;
	let mut other = -10;
	
	let hello = try ok("Yesssss") : hello => {
		print("Nooooo");
	};
	
	print(hello);
	
	(false) ? (8 == 9) ? correct : other : other = 0;

	// until allows you to end test the loop with the condition only breaking at the end of each iteration
	for i in 0..10 => print("hello") until true;

	// until also works with list comprehensions
	let lst = list[10 for i in 10 until i > 4];
	print(lst);	
	
	print(correct);
	print(other);
	
	// for i in 0..5 => print(i);
	print("Ho");
}
