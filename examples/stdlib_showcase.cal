import * from std::thread;
import * from std::option;
import * from std::crypto;
import * from std::regex;

const main = fn () => {
	let mut nums = list:<int>[1, 2, 3, 4, 5];
	
	print("pop => " & nums.pop());
	nums.insert(2, 99);
	nums.remove_value(4);
	print("nums => " & nums);
	print("slice => " & nums.slice(1, 3));
	print("sum/min/max => " & nums.sum() & ", " & nums.min() & ", " & nums.max());
	
	let words = list:<str>["alpha", "beta", "gamma"];
	
	print("join => " & words.join("-"));
	
	let text = "a\nb\nc\n";
	print("lines => " & text.split_lines());
	print("replace => " & text.replace("b", "B"));
	print("strip_prefix => " & "prefix_test".strip_prefix("pre"));
	
	let rng = 3..10;
	print("range len/contains => " & rng.len() & ", " & rng.contains(5));
	print("range sum => " & rng.sum());
	print("range to_list => " & rng.to_list());
	print("range is_empty => " & (0..0).is_empty());
	
	let squares = list:<int>[1, 2, 3, 4, 5].iter().map(fn (x : int) -> int => x * x).collect();
	print("squares => " & squares);
	
	let opt = some(10).map(fn (x : int) -> int => x + 1).unwrap_or(0);
	print("option map => " & opt);
	let opt2 = none.unwrap_or(123);
	print("option unwrap_or => " & opt2);
	let opt3 = some(5).and_then(fn (x : int) -> int? => if x > 3 => some(x * 3) else => none);
	print("option and_then => " & opt3);
	
	let res1 = ok(7).map(fn (x : int) -> int => x * 2);
	print("result map => " & res1);
	let res2 = err("oops").map_err(fn (e : str) -> str => "ERR: " & e);
	print("result map_err => " & res2);
	print("result is_ok => " & res1.is_ok());
	let res3 = ok(9).unwrap_or(0);
	print("result unwrap_or => " & res3);
	
	let dur = Duration.from_ms(150);
	print("duration ms => " & dur.as_ms());
	
	print("sha256 => " & sha256("abc"));
	print("regex is_match => " & is_match("a.c", "abc"));
};