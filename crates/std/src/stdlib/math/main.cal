const PI = 3.141592653589793f;
const TAU = 6.283185307179586f;
const E = 2.718281828459045f;
const EPSILON = 0.000000001f;

impl int {
	const min = fn (a b : int) -> int => if a < b => a else => b;
	const max = fn (a b : int) -> int => if a > b => a else => b;
	const abs = fn (x : int) -> int => if x < 0 => -x else => x;
	const sign = fn (x : int) -> int => if x < 0 => -1 else => if x > 0 => 1 else => 0;
	const clamp = fn (x lo hi : int) -> int => if x < lo => lo else => if x > hi => hi else => x;

	const pow = fn (base exp : int) -> int => {
		if exp < 0 => return 0;
		let mut b = base;
		let mut e = exp;
		let mut out = 1;
		
		for e > 0 => {
			if e % 2 == 1 => out = out * b;
			b = b * b;
			e = e / 2;
		};
		
		out;
	};

	const gcd = fn (a b : int) -> int => {
		let mut x = int.abs(a);
		let mut y = int.abs(b);
		for y != 0 => {
			let t = x % y;
			x = y;
			y = t;
		};
		x;
	};

	const lcm = fn (a b : int) -> int => {
		if a == 0 || b == 0 => 0 else => int.abs((a / int.gcd(a, b)) * b);
	};

	const factorial = fn (n : int) -> int => {
		if n < 0 => return 0;
		let mut out = 1;
		let mut i = 2;
		for i <= n => {
			out = out * i;
			i = i + 1;
		};
		out;
	};

	const permutations = fn (n r : int) -> int => {
		if n < 0 || r < 0 || r > n => 0 else => int.factorial(n) / int.factorial(n - r);
	};

	const combinations = fn (n r : int) -> int => {
		if n < 0 || r < 0 || r > n => 0 else => int.factorial(n) / (int.factorial(r) * int.factorial(n - r));
	};

	const is_prime = fn (n : int) -> bool => {
		if n < 2 => return false;
		if n == 2 => return true;
		if n % 2 == 0 => return false;
		let mut d = 3;
		for d * d <= n => {
			if n % d == 0 => return false;
			d = d + 2;
		};
		true;
	};
};

impl uint {
	const min = fn (a b : uint) -> uint => if a < b => a else => b;
	const max = fn (a b : uint) -> uint => if a > b => a else => b;
	const abs = fn (x : uint) -> uint => x;
	const sign = fn (x : uint) -> int => if x == 0u => 0 else => 1;
	const clamp = fn (x lo hi : uint) -> uint => if x < lo => lo else => if x > hi => hi else => x;

	const pow = fn (base exp : uint) -> uint => {
		let mut b = base;
		let mut e = exp;
		let mut out = 1u;
		
		for e > 0u => {
			if e % 2u == 1u => out = out * b;
			b = b * b;
			e = e / 2u;
		};
		
		out;
	};

	const gcd = fn (a b : uint) -> uint => {
		let mut x = a;
		let mut y = b;
		for y != 0u => {
			let t = x % y;
			x = y;
			y = t;
		};
		x;
	};

	const lcm = fn (a b : uint) -> uint => {
		if a == 0u || b == 0u => 0u else => (a / uint.gcd(a, b)) * b;
	};

	const factorial = fn (n : uint) -> uint => {
		let mut out = 1u;
		let mut i = 2u;
		for i <= n => {
			out = out * i;
			i = i + 1u;
		};
		out;
	};

	const permutations = fn (n r : uint) -> uint => {
		if r > n => 0u else => uint.factorial(n) / uint.factorial(n - r);
	};

	const combinations = fn (n r : uint) -> uint => {
		if r > n => 0u else => uint.factorial(n) / (uint.factorial(r) * uint.factorial(n - r));
	};

	const is_prime = fn (n : uint) -> bool => {
		if n < 2u => return false;
		if n == 2u => return true;
		if n % 2u == 0u => return false;
		let mut d = 3u;
		for d * d <= n => {
			if n % d == 0u => return false;
			d = d + 2u;
		};
		true;
	};
};

impl float {
	const min = fn (a b : float) -> float => if a < b => a else => b;
	const max = fn (a b : float) -> float => if a > b => a else => b;
	const abs = fn (x : float) -> float => if x < 0f => -x else => x;
	const sign = fn (x : float) -> int => if x < 0f => -1 else => if x > 0f => 1 else => 0;
	const clamp = fn (x lo hi : float) -> float => if x < lo => lo else => if x > hi => hi else => x;

	const approx_eq = fn (a b eps : float) -> bool => float.abs(a - b) <= float.abs(eps);
	const trunc = fn (x : float) -> int => try x as int => 0;

	const floor = fn (x : float) -> int => {
		let t = float.trunc(x);
		if x < 0f && (try t as float => 0f) != x => t - 1 else => t;
	};

	const ceil = fn (x : float) -> int => {
		let t = float.trunc(x);
		if x > 0f && (try t as float => 0f) != x => t + 1 else => t;
	};

	const round = fn (x : float) -> int => {
		if x >= 0f => float.floor(x + 0.5f) else => float.ceil(x - 0.5f);
	};

	const frac = fn (x : float) -> float => x - (try float.floor(x) as float => 0f);

	const pow = fn (base : float, exp : int) -> float => {
		if exp == 0 => return 1f;
		if exp < 0 => return 1f / float.pow(base, -exp);
		
		let mut b = base;
		let mut e = exp;
		let mut out = 1f;
		
		for e > 0 => {
			if e % 2 == 1 => out = out * b;
			b = b * b;
			e = e / 2;
		};
		
		out;
	};

	const sqrt = fn (x : float) -> float => {
		if x <= 0f => return 0f;
		let mut guess = if x < 1f => 1f else => x;
		let mut i = 0;
		for i < 32 => {
			guess = 0.5f * (guess + (x / guess));
			i = i + 1;
		};
		guess;
	};

	const cbrt = fn (x : float) -> float => {
		if x == 0f => return 0f;
		let mut guess = if float.abs(x) < 1f => x else => x / 3f;
		let mut i = 0;
		for i < 32 => {
			let g2 = guess * guess;
			if g2 == 0f => break;
			guess = (2f * guess + (x / g2)) / 3f;
			i = i + 1;
		};
		guess;
	};

	const exp = fn (x : float) -> float => {
		let mut sum = 1f;
		let mut term = 1f;
		let mut n = 1;
		for n < 32 => {
			term = term * (x / (try n as float => 1f));
			sum = sum + term;
			n = n + 1;
		};
		sum;
	};

	const ln = fn (x : float) -> float => {
		if x <= 0f => return 0f;
		let mut y = 0f;
		let mut i = 0;
		for i < 24 => {
			let ey = float.exp(y);
			if ey == 0f => break;
			y = y - ((ey - x) / ey);
			i = i + 1;
		};
		y;
	};

	const log10 = fn (x : float) -> float => float.ln(x) / float.ln(10f);
	const log2 = fn (x : float) -> float => float.ln(x) / float.ln(2f);

	const normalize_radians = fn (x : float) -> float => {
		let mut y = x;
		for y > PI => y = y - TAU;
		for y < -PI => y = y + TAU;
		y;
	};

	const sin = fn (x : float) -> float => {
		let y = float.normalize_radians(x);
		let y2 = y * y;
		let y3 = y2 * y;
		let y5 = y3 * y2;
		let y7 = y5 * y2;
		y - (y3 / 6f) + (y5 / 120f) - (y7 / 5040f);
	};

	const cos = fn (x : float) -> float => {
		let y = float.normalize_radians(x);
		let y2 = y * y;
		let y4 = y2 * y2;
		let y6 = y4 * y2;
		1f - (y2 / 2f) + (y4 / 24f) - (y6 / 720f);
	};

	const tan = fn (x : float) -> float => {
		let c = float.cos(x);
		if float.abs(c) <= EPSILON => 0f else => float.sin(x) / c;
	};

	const deg_to_rad = fn (deg : float) -> float => deg * (PI / 180f);
	const rad_to_deg = fn (rad : float) -> float => rad * (180f / PI);

	const lerp = fn (a b t : float) -> float => a + ((b - a) * t);
	const inv_lerp = fn (a b v : float) -> float => if a == b => 0f else => (v - a) / (b - a);
	const remap = fn (in_min in_max out_min out_max value : float) -> float => {
		float.lerp(out_min, out_max, float.inv_lerp(in_min, in_max, value));
	};
};
