extern "c" const c_fopen = fn(str, str) -> ptr:<@u8> from "libc" as "fopen";
extern "c" const c_fclose = fn(ptr:<@u8>) -> @int from "libc" as "fclose";
extern "c" const c_fflush = fn(ptr:<@u8>) -> @int from "libc" as "fflush";
extern "c" const c_fgets = fn(ptr:<@u8>, @int, ptr:<@u8>) -> str from "libc" as "fgets";
extern "c" const c_fwrite = fn(str, @usize, @usize, ptr:<@u8>) -> @usize from "libc" as "fwrite";
extern "c" const c_strlen = fn(str) -> @usize from "libc" as "strlen";
extern "c" const c_malloc = fn(@usize) -> ptr:<@u8> from "libc" as "malloc";
extern "c" const c_free = fn(ptr:<@u8>) -> null from "libc" as "free";
extern "c" const c_access = fn(str, @int) -> @int from "libc" as "access";
extern "c" const c_remove = fn(str) -> @int from "libc" as "remove";

type File = struct { handle : ptr:<uint> };

const open = fn (path : str, mode : str) -> ptr:<uint> => c_fopen(path, mode);

const open_read = fn (path : str) -> ptr:<uint> => c_fopen(path, "r");
const open_write = fn (path : str) -> ptr:<uint> => c_fopen(path, "w");
const open_append = fn (path : str) -> ptr:<uint> => c_fopen(path, "a");

const close = fn (handle : ptr:<uint>) => {
	if (try handle as int => 0) == 0 => return null;
	c_fclose(handle);
	null;
};

const flush = fn (handle : ptr:<uint>) => {
	if (try handle as int => 0) == 0 => return null;
	c_fflush(handle);
	null;
};

const write = fn (handle : ptr:<uint>, content) => {
	if (try handle as int => 0) == 0 => return null;
	let txt = "" & content;
	let len = c_strlen(txt);
	c_fwrite(txt, 1, len, handle);
	null;
};

const write_line = fn (handle : ptr:<uint>, content) => {
	write(handle, ("" & content) & "\n");
	null;
};

const exists = fn (path : str) -> bool => c_access(path, 0) == 0;

const remove = fn (path : str) -> bool => c_remove(path) == 0;

const read_line = fn (handle : ptr:<uint>, max : int) -> str => {
	if (try handle as int => 0) == 0 => return "";
	let size = if max <= 0 => 1 else => max + 1;
	let buf = c_malloc(size);
	let line = c_fgets(buf, size, handle);
	c_free(buf);
	line;
};

const read_lines = fn (handle : ptr:<uint>, max : int) -> list:<str> => {
	let mut out = list:<str>[];
	for  => {
		let line = read_line(handle, max);
		if len(line) == 0 => break;
		out <<= line;
	};
	out;
};

const read_all = fn (handle : ptr:<uint>, max : int) -> str => {
	let mut out = "";
	for  => {
		let line = read_line(handle, max);
		if len(line) == 0 => break;
		out &= line;
	};
	out;
};

const read_to_string = fn (path : str, max : int) -> str => {
	let handle = open_read(path);
	let txt = read_all(handle, max);
	close(handle);
	txt;
};

const read_lines_path = fn (path : str, max : int) -> list:<str> => {
	let handle = open_read(path);
	let lines = read_lines(handle, max);
	close(handle);
	lines;
};

impl File {
	const open = fn (path : str, mode : str) -> File => File { handle : open(path, mode) };

	const open_read = fn (path : str) -> File => File { handle : open_read(path) };

	const open_write = fn (path : str) -> File => File { handle : open_write(path) };

	const open_append = fn (path : str) -> File => File { handle : open_append(path) };

	const close = fn (self : &File) => close(self.handle);

	const flush = fn (self : &File) => flush(self.handle);

	const write = fn (self : &File, content) => write(self.handle, content);

	const write_line = fn (self : &File, content) => write_line(self.handle, content);

	const read_line = fn (self : &File, max : int) -> str => read_line(self.handle, max);

	const read_lines = fn (self : &File, max : int) -> list:<str> => read_lines(self.handle, max);

	const read_all = fn (self : &File, max : int) -> str => read_all(self.handle, max);
};
